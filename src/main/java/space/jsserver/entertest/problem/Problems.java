package space.jsserver.entertest.problem;

public final class Problems {
    public static final Problem[] BASICS = {
            new Problem("1", "在Minecraft Java版中，默认情况下按下哪一个按键可以丢出物品？", false, ""),
            new Problem("2", "Minecraft中的“酿造台”有什么用途？", false, ""),
            new Problem("3", "在Minecraft中，如何驯服一只狼？", false, ""),
            new Problem("4", "在Minecraft中，如何制作一个熔炉？", false, ""),
            new Problem("5", "在Minecraft中，如何制作一个火把？", false, ""),
            new Problem("6", "左图是Minecraft中的哪一个方块？", true, "resources/images/block1.png"),
            new Problem("7", "左图是Minecraft中的哪一个方块？", true, "resources/images/block2.png"),
            new Problem("8", "左图是Minecraft中的哪一个方块？", true, "resources/images/block3.png"),
            new Problem("9", "左图是Minecraft中的哪一个方块？", true, "resources/images/block4.png"),
            new Problem("10", "左图是Minecraft中的哪一个方块？", true, "resources/images/block5.png"),
            new Problem("11", "左图所示的合成配方得到的产物是什么？", true, "resources/images/crafting.png"),
    };
    public static final String[] REDSTONES = {
            "制作一个“粘性活塞”需要在普通活塞的基础上添加什么物品？",
            "红石信号的最大传输距离是多少格（不使用中继器或比较器）？",
            "红石火把除了提供持续红石信号，在什么情况下会熄灭？",
            "红石比较器检测到容器内物品越多，输出的红石信号强度会如何变化？",
            "在游戏中，“侦测器”的作用是检测什么，从而输出红石信号？",
            "红石信号通过“红石粉”传输时，每经过一格，信号强度会减少多少？"
    };

    public static final String[] CHATTING = {
            "在多人服务器中，未经他人允许就破坏他人建造的建筑，这种行为属于什么不良素质行为？遇到这种人之后，你的做法是什么？",
            "当其他玩家在服务器中询问游戏技巧时，正确的做法是什么？假如有人来询问你一个你不知道的问题，下面的答题方框就是你的聊天栏，请用恰当的语言进行表述。",
            "在多人联机中，故意用TNT炸毁公共区域，该行为违反了服务器通常的什么规则？如果你遇到了这种人，你会采取什么做法来制止他？",
            "遇到其他玩家在聊天栏发布不文明、辱骂性言论时，作为玩家的你应该怎么做（至少答两点）？",
            "当服务器出现卡顿或恶性bug时，正确的做法是立即向管理员反馈，还是恶意利用bug破坏服务器？为什么？",
            "当其他玩家无意间不小心破坏了你的少量方块时，良好的处理方式是什么？如果你是那位被不小心影响到的，请写下对那位玩家说的话，以消除两方之间的矛盾。",
            "当自己不小心误杀了其他玩家的宠物（如驯服的狼、猫），这位玩家非常生气，要去管理员那里告发你，说你在他家搞破坏，此时你会对他说什么，以打消他告发你的念头？假设下面的方框是你的聊天栏，请在里面写下你的话。",
            "遇到玩家之间发生矛盾争执时，良好的做法是煽风点火加剧矛盾，还是主动调解、劝说双方冷静？如果你是第三者，面对一个无谓的矛盾，请在下面写下你的做法。",
            "假如你是服务器的管理，你发现某玩家在聊天中发布了“剑殇没有死亡不掉落，就是个垃圾服务器”的言论，你会如何处理？请写下你的处理方式或对这位玩家说的话。",
            "假设你在游玩过程中，遇到了突如其来的卡顿现象，此时你的第一反应是什么？请写下你的做法。"
    };

    public static final String[] HIGH_LEVEL_REDSTONE = {
            """
（通用红石·一）探究：众所周知，Minecraft Java版的游戏刻是本游戏的基本时间单位。然而，游戏刻真的不可再分吗？
通过翻阅mcp-reborn反编译并反混淆出来的Minecraft源代码，我们可以知道，游戏刻中各个事件的处理实际上存在内部逻辑顺序，即“微时序”。大致的逻辑顺序如下：
1.WTU——即更新游戏中的世界时间；
2.NTE——即处理计划刻带来的延迟事件；
3.RTC——即处理游戏的随机刻事件；
4.V——即处理游戏的村庄事件；
5.BE——即处理游戏中的方块事件；
6.EU——即引发或处理该游戏刻下的实体更新事件；
7.TE——即处理游戏中的方块实体事件；
8.NU——即处理该游戏刻下发生的玩家触发的一切玩家操作。
同时，我们又知道，活塞的推出分为这样几个步骤依次执行：
BE时刻，程序读取活塞方向上的“可被推动的”一切方块，创建方块列表 --> 以更新的方向默认顺序将列表中的方块逐个替换为“36号方块” --> 按照顺序删除列表中的方块，将活塞替换为活塞头 --> TE时刻，将列表中的方块逐个放置在预定位置，并将活塞方向上的前一个方块替换为活塞臂。
因此，我们可以解释一种借助珊瑚扇完成的TNT复制结构的原理：
首先，TNT本身处于bud激活状态 --> 开始将“列表”中的方块替换为“36号方块” --> 由于珊瑚扇不可依附在“36号方块”上，因此珊瑚扇发生掉落事件，产生方块更新；又由于珊瑚扇的依附方块的被替换早于TNT方块的被替换，TNT被激活 --> EU时刻，点燃的TNT实体生成 --> TE时刻，所有方块到达指定位置；而由于TNT方块本身已经处于“列表”中，因此仍会有TNT被放置在目标位置。
下面，请借助“微时序”这一强大工具，解释“无头活塞破基岩”现象（即“活塞头”方块在BUD态下被激活后，活塞方向上所正对着的那一个方块会被强制删除变为空气）的原理。
""",
            """
（通用红石·二）“更新抑制器”常被应用于“切门”等生电建造操作。

众所周知，Java版Minecraft是运行在Java虚拟机（JVM）之上的，而计算机的内存可以分为“堆”和“栈”两部分。
我们知道，如果我们设某x86架构下过程调用遵循cdecl规范，当指令指针寄存器（EIP）发生控制流转移时，在逻辑地址空间的用户态栈段中将动态构建过程活动记录（Procedure Activation Record）。其内存布局自高地址向低地址延拓，依次包含：实际参数副本、返回地址（由CALL指令隐式压栈）、基址指针（EBP，用于建立栈帧锚点）、局部变量存储区及对齐填充。此时栈顶指针（ESP）与EBP构成动态链（Dynamic Chain），实现词法作用域的运行时环境寻址。
若某递归函数未满足递归基终止条件，将导致栈帧空间持续以△n（n=局部变量总大小 + 对齐开销）的速率沿虚拟地址负向增长。当累计帧大小超越操作系统预设的线程栈容量上限（如Linux默认8MB），则触发页保护异常（Page Fault），引发存储管理单元（MMU）的栈溢出硬件中断。
在JVM的运行时数据区中，每个线程独享的Java虚拟机栈以栈帧（Stack Frame）为基本执行单元。其帧结构包含局部变量表（Local Variable Array，以Slot为最小寻址单元）、操作数栈（Operand Stack，基于逆波兰表示执行字节码指令）、动态链接（指向运行时常量池的方法引用）及方法返回地址。当通过解释器或即时编译器（JIT）执行方法调用时，若递归深度或链式调用层级使栈帧总尺寸突破-Xss参数定义的栈容量阈值，JVM将抛出StackOverflowError异常。此错误源于栈内存分配失败，属于VirtualMachineError的子类，表征JVM不可恢复的致命状态。

由上述材料，请解释“更新抑制器”的底层原理。
"""
    };
    public static final String HIGH_LEVEL_SURVIVAL =
            """
（生电）（不定项）下列说法正确的是 （  ）

A. 更新跳略器的原理是同时产生大量更新使得同一游戏刻内的更新队列被“排满”，导致后面的更新被直接“跳略”。因为与一些更新抑制器不同，更新跳略器并没有导致服务端抛出StackOverflowError，所以该更新跳略器的运行结果与栈内存上的情况无关；
B. 某玩家在竖直方向（y方向）上，自下而上地搭建了形如“粘性活塞-粘液块-红石块”的BUD结构。当最下面的粘性活塞接收到方块更新时，将会产生一次推出行为。这里的BUD激活方式可以被称为“QC激活”；
C. 大多数种类的袭击塔在建造时均需要对齐区块/区段，这是因为触发袭击时，袭击生成任何一种怪物时的游走范围与当前目标村庄所在的区块、区段均以同种方式对齐；
D. 活塞、发射器等红石元件之所以可以产生形如“侧上方激活”的BUD激活形式，是因为这些红石元件检测是否被激活的范围与门方块相同；
E. 某玩家使用自动化脚本实现了破基岩。大致实现思路为：放置一个活塞后激活，而后在一瞬间破坏活塞头方块与充能源，在其原本位置上放置一个朝向目标基岩的活塞。该脚本的原理可以大致解释为：在此过程中，原活塞目标方向上的活塞臂方块发生方块状态错误（即其对应的活塞头方块状态异常），这将导致Minecraft服务端抛出ClassCastException，使得该游戏刻下的EU、TE、NU运算均被强制跳略，从而实现破基岩。
F. 刷怪术语中的“LC值”也可以被定义为：所选区块中最高方块的y坐标值。
""";
    public static final String HIGH_LEVEL_DIGITAL =
            """
（数电）要将二进制数转换为十进制，有人提出了一种“左移满八减三”方法，具体实现如下：
（1）将目标二进制数补充为四的倍数位（如101001补充为00101001），并以四位为单位进行分割；
（2）将最右边的那一位与1000（即十进制下的8）比较大小，若小于1000，则将数据整体左移一位；若大于1000，则减去0011后左移一位，空位以0补充，多出的最右边的那一个数字存入缓存；
（3）以此类推，对以下所有结果实施上述操作，多出的数字放在上一位缓存数的左边，最终使得数据栈中所有数字均为0；
（4）最终得到的缓存数即为十进制数对应的BCD码。
该方法在8位以上的二进制数中是否可行？为什么？
""";
    public static final String[] HIGH_LEVEL_CODING = {
            """
（编程·一）面向对象（OOP）是一种重要且广泛应用的编程思想。
设计并实现一个任务调度系统，系统需要支持添加多个任务，每个任务包含唯一的整数ID、一个整数优先级以及一个整数执行时长，调度系统在一个固定的时间片内运行时，会根据任务的优先级来决定执行顺序，优先级高的任务先执行，如果多个任务优先级相同，则按照任务ID从小到大的顺序执行，当一个任务的执行时长大于时间片时，任务只能在该时间片内部分执行，剩余时长应被保留以便在下一个时间片继续执行，要求编写程序实现该任务调度逻辑，并输出在给定若干个时间片内所有任务的执行顺序及每次执行的时长。
=====任务结构=====
每个任务对象均包含以下字段：
id：整数，唯一标识任务，例如 1, 2, 3
priority：整数，优先级，数值越大表示优先级越高
duration：整数，总执行时长（单位为时间片内的基本单位，例如 1ms 或 1tick）
remaining：整数，剩余未执行的时长（初始化时等于 duration）
=====调度规则=====
所有任务在调度开始前已添加到任务队列中。
调度器在每个时间片开始时，从任务队列中选择任务执行：
优先根据 priority 降序选择；
若优先级相同，则按 id 升序选择。
如果任务的 remaining 时长 ≥ 时间片大小，则该任务在本时间片中执行时间片大小，并更新 remaining；
如果 remaining 时长 < 时间片大小，则该任务在本时间片中执行 remaining，并标记该任务完成；
调度器继续下一个时间片，直到所有任务执行完毕。
=====接口需求=====
需要实现以下接口或方法：
addTask(int id, int priority, int duration)：向调度器中添加任务
schedule(int timeSlice)：按照调度规则执行任务，直到所有任务完成，并返回每个时间片内任务的执行情况
输出格式：应输出每个时间片执行的任务ID和实际执行时长
=====示例=====
假设时间片大小为 3，输入任务如下：
Task 1: id=1, priority=2, duration=4
Task 2: id=2, priority=1, duration=6
Task 3: id=3, priority=2, duration=2
=====调度过程=====
时间片1：Task1（优先级2，id=1），执行3，剩余1
时间片2：Task3（优先级2，id=3），执行2（已完成）
时间片3：Task1（剩余1），执行1（已完成）
时间片4：Task2（优先级1，id=2），执行3，剩余3
时间片5：Task2，执行3（已完成）
=====输出示例=====
Slice 1: Task 1 executed 3
Slice 2: Task 3 executed 2
Slice 3: Task 1 executed 1
Slice 4: Task 2 executed 3
Slice 5: Task 2 executed 3
================
请用你所擅长的那一门编程语言，完成上述题目，并将代码在编辑器中写完后粘贴在下面的方框中。
""",
            """
（编程·二）面向过程（Procedural Programming）是一种常用的编程思想，通过函数调用和过程逻辑来组织程序。
设计并实现一个 图书管理系统，系统需要支持添加多本图书，每本图书包含唯一的整数ID、书名、作者、总库存以及当前可借数量，用户可以借书或还书。系统在借书时，如果库存足够，则更新可借数量；如果库存不足，记录借书请求为待处理状态；还书时，自动处理待处理的借书请求。要求使用面向过程的方式编写程序实现图书管理逻辑，并输出每次借书、还书以及待处理请求的状态。
=====图书结构=====
每本图书包含以下存储内容：
id：整数，唯一标识图书，例如 1, 2, 3
title：字符串，书名
author：字符串，作者
totalStock：整数，总库存
available：整数，当前可借数量
pendingRequests：队列，存储无法立即借出的用户请求
=====操作规则=====
用户可以调用 borrowBook(int bookId, String userName) 借书：
如果 available > 0，则允许借书，available -= 1
如果 available == 0，将用户请求加入 pendingRequests 队列
用户可以调用 returnBook(int bookId) 还书：
增加 available += 1
如果 pendingRequests 队列非空，自动将队列头的请求分配借书，并减少 available
系统可调用 addBook(int id, String title, String author, int totalStock) 添加新书
=====接口需求=====
需要实现以下函数（这里是伪代码）：
addBook(int id, String title, String author, int totalStock)：添加新书
borrowBook(int bookId, String userName)：用户借书
returnBook(int bookId)：用户还书
printStatus()：输出当前每本书的 available、pendingRequests
=====示例=====
输入操作：
addBook(1, "C语言编程思想", "Bruce Eckel", 2)
addBook(2, "算法导论", "CLRS", 1)
borrowBook(1, "Alice")
borrowBook(1, "Bob")
borrowBook(1, "Charlie")
borrowBook(2, "Dave")
borrowBook(2, "Eve")
returnBook(1)
=====输出示例=====
Book 1: available=0, pendingRequests=[Charlie]
Book 2: available=0, pendingRequests=[Eve]
After Alice returns Book 1:
Book 1: available=0, pendingRequests=[]
================
请用你所擅长的编程语言完成上述题目，并将代码在编辑器中写完后粘贴在下面的方框中。
"""
    };
}
